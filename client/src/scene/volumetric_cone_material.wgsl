#import bevy_pbr::{
    mesh_view_bindings::{globals, view},
    forward_io::VertexOutput,
}



// Material bindings generated by AsBindGroup for VolumetricConeMaterial
@group(2) @binding(0) var<uniform> material_color: vec4<f32>;
// params0: (absorb_r, absorb_g, absorb_b, view_fresnel_strength)
@group(2) @binding(1) var<uniform> material_params0: vec4<f32>;
// params1: (noise_strength, noise_scale, falloff_pow, edge_soften)
@group(2) @binding(2) var<uniform> material_params1: vec4<f32>;
@group(2) @binding(3) var<uniform> material_flicker_amps: vec4<f32>;
@group(2) @binding(4) var<uniform> material_flicker_freqs: vec4<f32>;
@group(2) @binding(5) var<uniform> material_flicker_phases: vec4<f32>;
@group(2) @binding(6) var<uniform> material_hdr_params: vec4<f32>;

fn hash33(p: vec3<f32>) -> vec3<f32> {
    var q = vec3<f32>(
        dot(p, vec3<f32>(127.1, 311.7, 74.7)),
        dot(p, vec3<f32>(269.5, 183.3, 246.1)),
        dot(p, vec3<f32>(113.5, 271.9, 124.6))
    );
    return fract(sin(q) * 43758.5453);
}

fn compute_volumetric_fog(
    world_position: vec3<f32>,
    base_rgb: vec3<f32>,  // e.g. material_color.rgb * absorb
    emit: f32,            // HDR light output multiplier
    alpha: f32            // visual alpha for sorting/blending
) -> vec4<f32> {
    let fog_density = 0.1; // was too harsh at 10.0

    let cam_pos = view.world_position;
    // Exponential falloff
    let dist = distance(view.world_position, world_position);

    let fog_attenuation = exp(-fog_density * dist);


    let visible_rgb = base_rgb * emit * fog_attenuation;

    let final_rgb = visible_rgb;

    return vec4<f32>(final_rgb, alpha);
}

fn noise3(p: vec3<f32>) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);

    let a = hash33(i);
    let b = hash33(i + vec3<f32>(1.0, 0.0, 0.0));
    let c = hash33(i + vec3<f32>(0.0, 1.0, 0.0));
    let d = hash33(i + vec3<f32>(1.0, 1.0, 0.0));
    let e = hash33(i + vec3<f32>(0.0, 0.0, 1.0));
    let f1 = hash33(i + vec3<f32>(1.0, 0.0, 1.0));
    let g = hash33(i + vec3<f32>(0.0, 1.0, 1.0));
    let h = hash33(i + vec3<f32>(1.0, 1.0, 1.0));

    let x1 = mix(a.x, b.x, u.x);
    let x2 = mix(c.x, d.x, u.x);
    let x3 = mix(e.x, f1.x, u.x);
    let x4 = mix(g.x, h.x, u.x);
    let y1 = mix(x1, x2, u.y);
    let y2 = mix(x3, x4, u.y);
    return mix(y1, y2, u.z);
}

fn fbm(p_in: vec3<f32>) -> f32 {
    var p = p_in;
    var sum = 0.0;
    var amp = 0.5;
    var freq = 1.0;
    for (var i = 0; i < 4; i = i + 1) {
        sum += amp * noise3(p * freq);
        freq *= 2.0;
        amp *= 0.5;
    }
    return sum; // in [0,1]
}

@fragment
fn fragment(in: VertexOutput) -> @location(0) vec4<f32> {
    // Mesh UVs: water.rs builds the cone with v=1 at apex and v=0 at base ring
    // Use that as a clean 0..1 distance proxy along the cone
    let v = in.uv.y;
    let dist01 = clamp(1.0 - v, 0.0, 1.0);

    let absorb = material_params0.xyz; // per-channel absorption multipliers
    let fresnel_strength = material_params0.w; // view-angle brightening
    let noise_strength = material_params1.x;
    let noise_scale = material_params1.y;
    let falloff_pow = max(material_params1.z, 0.001);
    let edge_soften = material_params1.w; // softening near apex/base


    // Base intensity shaped along the cone length
    // Favor apex, fade towards base using a power profile
    let along = pow(1.0 - dist01, falloff_pow);
    // Extra attenuation with distance from the source (apex)
    // This inverse-square-like term makes the cone lose brightness faster
    let dist_attn = 1.0 / (1.0 + 6.0 * dist01 * dist01);

    // Edge smoothing towards apex and base
    let fade_apex = smoothstep(0.0, edge_soften, dist01);
    let fade_base = 1.0 - smoothstep(1.0 - edge_soften, 1.0, dist01);
    let edge = min(fade_apex, fade_base);

    // View-angle brightening (simple Fresnel-like term)
    let V = normalize(view.world_position - in.world_position.xyz);
    let N = normalize(in.world_normal);
    let ndotv = max(dot(N, V), 0.0);
    let fresnel = pow(1.0 - ndotv, 5.0);
    let view_boost = 1.0 + fresnel_strength * fresnel;

    // Unit-cone local 3D noise from UVs to avoid distortion from non-uniform world scaling
    // Reconstruct unit cone local pos: theta from u, radius from (1 - v), z from v
    let theta = in.uv.x * 6.28318530718;
    let r = max(0.0, 1.0 - v);
    let local_pos = vec3<f32>(r * cos(theta), r * sin(theta), v);
    let t = globals.time * 0.25;
    let p = local_pos * noise_scale + vec3<f32>(t * 0.1, -t * 0.08, t * 0.06);
    let n = (fbm(p) - 0.5) * 2.0; // remap to [-1,1]
    let noise_mul = 1.0 + noise_strength * n;

    // Wavelength-dependent absorption along the cone
    // Larger absorb.x removes red more quickly than G/B
    let absorb_vec = exp(-absorb * dist01);

    let base_rgb = material_color.rgb * absorb_vec;
    // Multi-frequency low-amplitude flicker in intensity
    let two_pi = 6.28318530718;
    let flicker = 1.0
        + material_flicker_amps.x * sin(two_pi * material_flicker_freqs.x * globals.time + material_flicker_phases.x)
        + material_flicker_amps.y * sin(two_pi * material_flicker_freqs.y * globals.time + material_flicker_phases.y)
        + material_flicker_amps.z * sin(two_pi * material_flicker_freqs.z * globals.time + material_flicker_phases.z);


    let dist_from_axis = length(local_pos.xy); // 0.0 at center, 1.0 at edge
    let edge_noise = smoothstep(0.9, 1.0, dist_from_axis + 0.05 * noise3(local_pos));
    
    //edge softeing
    let edge_soft = 1.0 - smoothstep(0.85, 1.0, dist_from_axis);

    // Emissive output: allow values > 1.0 for HDR+bloom
    var emit = material_hdr_params.x * material_color.a * along * dist_attn * edge * view_boost * noise_mul * max(flicker, 0.01);
    emit *= (1.0 - edge_noise) * edge_soft;
    // Visual alpha: keep in [0,1] to be well-behaved with transparency sorting
    let final_alpha = clamp(material_color.a * along * dist_attn * edge * edge_soft, 0.0, 1.0);


    let final_color = compute_volumetric_fog(in.world_position.xyz, base_rgb, emit, final_alpha);

    //let final_color = color;
    return final_color;
}
